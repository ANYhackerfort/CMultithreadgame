Project by: Matthew Zhang & Tony Li

============
The objective is to create an Elden Ring open world game. This game has 10 maps (or areas) like Elden ring, and each area has 9 squares (different parts of each map). The user can tp to any map even while they are completing a square, but once you leave, the square of the level they are on gets reset (like an elden ring boss) but the other bosses (squares) that you beat gets saved so users can skip through the beat areas of the map to access other parts. Progress is stored in 10 map objects, but if you die, YOU LOSE EVERYTHING. Read more to learn the quirk on teleportation. 
============

Teleportation:
- Users can always /displaymap to get all the maps you can travel to and once you enter the code, you can travel there (like an elden ring map).
- However, the position you teleport to will be the same as the postition on the current map. EX: if you are in position (1,1) on current map, teleporting to another map still puts you at (1,1);
- This limits your movement as you can not traverse the map freely as you are always prompted to beat whats on the current square. 

Other commands:
- When you are traveling with an animation, you are hinted at commands to check your health and items in your inventory. 

Rules:
- Once you lose all your health, all progress is lost at that square, you have to start over.
- Items are rare but once you find them, you can use it to skip past attacks. 
- When you decide to move away to another square, all progress is lost. That's the challenging part! 
- Once you beat the square, the number of square beat gets incremented, you can not try to beat the square again!

How to win:
- You only need to complete 10 squares of the ten maps, you can choose any. But once you lose all your health! GAME OVER EVERYTHING RESETS!

The whole code is written by us while referring to slides / past coding assignments. We also referred to resources such as stack overflow for debugging for std::shared_ptrs and race conditions of having 2 threads (we just have 1 now, apprently its race conditioning the reading of the input conosle and the output console). 

IMPORTANT:
How Topics Are Used:

Extra:
All of the topics are used in the corresponding maps.
This is essentially a trivia game, topic 1 is in map 1, topic 2 is in map 2, etc. 

1. Standard containers:
used throughout all of the classes to store information of various types
2. Custom Template Class:
inventory is a custom template class that is used to store the inventory information of the player
3. Custom Namespace
Util is a custom namespace that is used for a template quicksort function
4. Classes with Constructor, Destructor, Assignment Operator
The gameItem class has all three, all of the other classes have a constructor and destructor but no custom assignment operator, but there is still the default c++ assignment operator. 
5. Lambda Functions
We used a lambda function to display the loading screen. 
6. Exception Handling
For all commands, there are exception throws and catches to make sure all commands are valid
7. Inheritance 
basemap inherits from adventuregame, and each topic class inherits from basemap
8. Virtual Functions or Abstract Classes
handleCurrentSquare() in basemap class is virtual, so is all of the relevant destructors
9. Hashing
Our inventory is a custom hash table
10. Sorting Algorithms
there are options to sort the items in the inventory for different things. We used quicksort to have a low average time complexity. 

#In depth:
game.cpp/adventuregame.cpp/basegame.cpp/topic1.cpp/topic2.cpp...etc:
    Topics Used:
    4. loadmaps initializes all maps, deletemaps deletes all, TopicMaps have constructors and destructors
    5. The displayAnimation function in handleMapSelection uses a lambda function 
    6. Exception handling is extensively used for managing invalid user inputs
    7. Topic1, Topic2... etc are derived from basemap class
    8. virtual functions are implemented in basemap.cpp and maingame.cpp

inventory.h:
    Topics Used:
    1.The class heavily utilizes std::vector and std::list 
    2.This entire class is a custom template class
    4.Constructor is defined

    9.Hashing: Hashing is explicitly implemented in the hashFunction method, which uses std::hash to map keys to bucket indices.

sort.h:
    Topics used:
    1.The std::vector container is central to the implementation of the sorting algorithm.
    2.This is a custom template class(ish)
    3.Util is a custom namespace defined for utility
    10. quicksort is implemented here

gameItem.h
    Topics used:
    4. Constructor, Destructor, and Assignment operator are all implemented in this class
    7. The 4 items are inherited from GameItem class

Hardships while making this project:
    -Lots of bugs
    -Template Classes are really hard to work with
    -Tedious to update and change everything
    -Template functions are really hard to work with
    -Properly using threading
    -Makefile Issues
    -Lots of makefile Issues
    -scuffed inheritance is hard to change after you already built something on it
    -concepts were hard to come up with
    -git merge/pull/update/branch/etc
    -time restraints
    